/*
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * 
 *
 * This file is a generated sample test application.
 *
 * This application is intended to test and/or illustrate some 
 * functionality of your system.  The contents of this file may
 * vary depending on the IP in your system and may use existing
 * IP driver functions.  These drivers will be generated in your
 * SDK application project when you run the "Generate Libraries" menu item.
 *
 */


#include <stdio.h>
#include "xparameters.h"
#include "xil_cache.h"
#include "xuartlite.h"
#include "xbasic_types.h"
#include "xgpio.h"
#include "my_keypad.h"
/*#include "gpio_header.h"
*/

#include <xstatus.h>

#define XPAR_RS232_UART_1_BASEADDR 0x84000000
#define LEDs_HW_BASEaddress (0x81420000)
#define BASE ADDRESS KEYPAD 0x84014000

int getNumber (){

	Xuint8 byte;
	Xuint8 uartBuffer[16];
	Xboolean validNumber;
	int digitIndex;
	int digit, number, sign;
	int c;

	while(1){
		byte = 0x00;
		digit = 0;
		digitIndex = 0;
		number = 0;
		validNumber = XTRUE;

		//get bytes from uart until RETURN is entered

		while(byte != 0x0d && byte != 0x0A){
			byte = XUartLite_RecvByte(XPAR_RS232_UART_1_BASEADDR);
			uartBuffer[digitIndex] = byte;
			XUartLite_SendByte(XPAR_RS232_UART_1_BASEADDR,byte);
			digitIndex++;
		}

		//calculate number from string of digits

		for(c = 0; c < (digitIndex - 1); c++){
			if(c == 0){
				//check if first byte is a "-"
				if(uartBuffer[c] == 0x2D){
					sign = -1;
					digit = 0;
				}
				//check if first byte is a digit
				else if((uartBuffer[c] >> 4) == 0x03){
					sign = 1;
					digit = (uartBuffer[c] & 0x0F);
				}
				else
					validNumber = XFALSE;
			}
			else{
				//check byte is a digit
				if((uartBuffer[c] >> 4) == 0x03){
					digit = (uartBuffer[c] & 0x0F);
				}
				else
					validNumber = XFALSE;
			}
			number = (number * 10) + digit;
		}
		number *= sign;
		if(validNumber == XTRUE){
			return number;
		}
		print("This is not a valid number.\n\r");
	}
}


int main() 
{

	XGpio Gpio_LEDs; /* The driver instance for GPIO Device configured as Salida */
	XGpio GpioSwitches;  /* The driver instance for GPIO Device configured as Entrada */
	int DataReadA;
	int DataReadB;
	int DataRead;
	int result;
	char key;
	u32 valor;
	u32 old_valor;
	Xil_ICacheEnable();
   Xil_DCacheEnable();

  // print("---Test para switches y leds---\n\r");
   print(" ---Test para el keypad ---\n\r");
   baseaddr = BASE ADDRESS KEYPAD ;
   xil printf(" Pulse una tecla cualquiera \n\r");
   valor = KEYPAD_mReadReg ( baseaddr , 0);
   xil printf (" Se ha leido %d del registro 0 del teclado \n\r" , Reg32Value );
   KEYPAD_mWriteReg ( baseaddr , 16 ,0);
   old_valor = valor ; /* Se escribe un 0 para borrar la última tecla leída */
   while (1) {
   if ( valor != old_valor ) {
   xil printf (" Se ha leido %d del registro 0 del teclado \n\r" , valor );
   old_valor = valor ;
   }
   valor = KEYPAD_mReadReg ( baseaddr , 0);
   KEYPAD_mWriteReg ( baseaddr , 16 ,0); /* Se escribe un 0 para borrar la última tecla leída */
   }


			// Configuraci�n de la GPIO para los LEDs de la placa extendida
			/*XGpio_Initialize(&Gpio_LEDs, XPAR_LEDS_DEVICE_ID);
			XGpio_SetDataDirection(&Gpio_LEDs, 1, 0x0);

			// Configuraci�n de la GPIO para los Switches
			XGpio_Initialize(&GpioSwitches, XPAR_SWITCHES_DEVICE_ID);
			XGpio_SetDataDirection(&GpioSwitches, 1, 0xFF);

			while(1){
				xil_printf("Introduce una letra\n\r");
				xil_printf("a.Introduce primer operando y visualizalo en los leds y la pantalla \n\r");
				xil_printf("b.Introduce segundo operando y visualizalo en los leds y la pantalla \n\r");
				xil_printf("c.Sumar y visualizar el resultado en los leds y en la pantalla\n\r");
				xil_printf("d.lee switches y muestralos por pantalla\n\r");

				key = XUartLite_RecvByte(XPAR_RS232_UART_1_BASEADDR);
				XUartLite_SendByte(XPAR_RS232_UART_1_BASEADDR,key);
						print("\r\n");
				XUartLite_RecvByte(XPAR_RS232_UART_1_BASEADDR);
				if(key == 'a'){
					do{
					xil_printf("Introduce un numero\n\r");
					DataReadA=getNumber();
					}while(DataReadA==0);
					xil_printf("Numero A %d\n\r",DataReadA);
					// Escribir el dato leido en los LEDs de la placa extendida
					XGpio_DiscreteWrite(&Gpio_LEDs, 1, DataReadA);
					XUartLite_RecvByte(XPAR_RS232_UART_1_BASEADDR);
				}
				else if(key=='b'){
					do{
					xil_printf("Introduce un numero\n\r");
					DataReadB=getNumber();
					}while(DataReadB==0);
					xil_printf("Numero B %d\n\r",DataReadB);
					// Escribir el dato leido en los LEDs de la placa extendida
					XGpio_DiscreteWrite(&Gpio_LEDs, 1, DataReadB);
					XUartLite_RecvByte(XPAR_RS232_UART_1_BASEADDR);
				}
				else if(key=='c'){
					result= DataReadA + DataReadB;
					xil_printf("Resultado %d\n\r",result);
					// Escribir el dato leido en los LEDs de la placa extendida
					XGpio_DiscreteWrite(&Gpio_LEDs, 1, result);
					XUartLite_RecvByte(XPAR_RS232_UART_1_BASEADDR);
				}
				else if(key== 'd'){
					DataRead = XGpio_DiscreteRead(&GpioSwitches, 1);
					xil_printf("Se muestra el valor  %d leido de los switches\n\r",DataRead);
					// Escribir el dato leido en los LEDs de la placa extendida
					XGpio_DiscreteWrite(&Gpio_LEDs, 1, DataRead);
					XUartLite_RecvByte(XPAR_RS232_UART_1_BASEADDR);
				}
				*/
				 //DataRead = XGpio_DiscreteRead(&GpioSwitches, 1);

			/*
					* Lee de nuevo el estado de los switches
			*/

			//}



   print("---Exiting main---\n\r");

   Xil_DCacheDisable();
   Xil_ICacheDisable();

   return 0;
}





